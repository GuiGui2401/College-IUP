{"ast":null,"code":"/**\n * Système de limitation de débit côté client\n * Évite les erreurs HTTP 429 en limitant le nombre de requêtes par seconde\n */class RateLimiter{constructor(){let maxRequests=arguments.length>0&&arguments[0]!==undefined?arguments[0]:10;let timeWindow=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1000;this.maxRequests=maxRequests;// Nombre max de requêtes\nthis.timeWindow=timeWindow;// Fenêtre de temps en ms\nthis.requests=[];// Historique des requêtes\nthis.queue=[];// File d'attente des requêtes\nthis.processing=false;// Flag de traitement\n}/**\n     * Ajoute une requête à la file d'attente\n     */async execute(requestFunction){return new Promise((resolve,reject)=>{this.queue.push({request:requestFunction,resolve,reject});this.processQueue();});}/**\n     * Traite la file d'attente des requêtes\n     */async processQueue(){if(this.processing||this.queue.length===0){return;}this.processing=true;while(this.queue.length>0){// Nettoyer les anciennes requêtes\nconst now=Date.now();this.requests=this.requests.filter(timestamp=>now-timestamp<this.timeWindow);// Vérifier si on peut faire une nouvelle requête\nif(this.requests.length>=this.maxRequests){// Attendre jusqu'à ce qu'une requête sorte de la fenêtre\nconst oldestRequest=Math.min(...this.requests);const waitTime=this.timeWindow-(now-oldestRequest);if(waitTime>0){console.log(`Rate limiter: waiting ${waitTime}ms before next request`);await this.delay(waitTime);continue;}}// Exécuter la prochaine requête\nconst{request,resolve,reject}=this.queue.shift();this.requests.push(Date.now());try{const result=await request();resolve(result);}catch(error){reject(error);}// Petit délai entre les requêtes pour éviter de surcharger\nawait this.delay(50);}this.processing=false;}/**\n     * Utilitaire pour créer un délai\n     */delay(ms){return new Promise(resolve=>setTimeout(resolve,ms));}/**\n     * Réinitialise le limiteur\n     */reset(){this.requests=[];this.queue=[];this.processing=false;}/**\n     * Obtient les statistiques actuelles\n     */getStats(){const now=Date.now();const recentRequests=this.requests.filter(timestamp=>now-timestamp<this.timeWindow).length;return{queueLength:this.queue.length,recentRequests,maxRequests:this.maxRequests,canMakeRequest:recentRequests<this.maxRequests};}}// Instance globale du limiteur de débit\n// Limite à 5 requêtes par seconde pour être conservateur\nconst globalRateLimiter=new RateLimiter(5,1000);/**\n * Fonction wrapper pour appliquer la limitation de débit à une requête\n */export const withRateLimit=async requestFunction=>{return globalRateLimiter.execute(requestFunction);};/**\n * Hook React pour surveiller l'état du rate limiter\n */// export const useRateLimiterStats = () => {\n//     // Import dynamique pour éviter les dépendances circulaires\n//     if (typeof window !== 'undefined' && window.React) {\n//         // const { useState, useEffect } = window.React;\n//         const [stats, setStats] = useState(globalRateLimiter.getStats());\n//         useEffect(() => {\n//             const interval = setInterval(() => {\n//                 setStats(globalRateLimiter.getStats());\n//             }, 100);\n//             return () => clearInterval(interval);\n//         }, []);\n//         return stats;\n//     }\n//     return globalRateLimiter.getStats();\n// };\nexport default globalRateLimiter;","map":{"version":3,"names":["RateLimiter","constructor","maxRequests","arguments","length","undefined","timeWindow","requests","queue","processing","execute","requestFunction","Promise","resolve","reject","push","request","processQueue","now","Date","filter","timestamp","oldestRequest","Math","min","waitTime","console","log","delay","shift","result","error","ms","setTimeout","reset","getStats","recentRequests","queueLength","canMakeRequest","globalRateLimiter","withRateLimit"],"sources":["/var/www/College-IUP/front/src/utils/rateLimiter.js"],"sourcesContent":["/**\n * Système de limitation de débit côté client\n * Évite les erreurs HTTP 429 en limitant le nombre de requêtes par seconde\n */\n\nclass RateLimiter {\n    constructor(maxRequests = 10, timeWindow = 1000) {\n        this.maxRequests = maxRequests; // Nombre max de requêtes\n        this.timeWindow = timeWindow;   // Fenêtre de temps en ms\n        this.requests = [];             // Historique des requêtes\n        this.queue = [];               // File d'attente des requêtes\n        this.processing = false;       // Flag de traitement\n    }\n\n    /**\n     * Ajoute une requête à la file d'attente\n     */\n    async execute(requestFunction) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({\n                request: requestFunction,\n                resolve,\n                reject\n            });\n\n            this.processQueue();\n        });\n    }\n\n    /**\n     * Traite la file d'attente des requêtes\n     */\n    async processQueue() {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            // Nettoyer les anciennes requêtes\n            const now = Date.now();\n            this.requests = this.requests.filter(\n                timestamp => now - timestamp < this.timeWindow\n            );\n\n            // Vérifier si on peut faire une nouvelle requête\n            if (this.requests.length >= this.maxRequests) {\n                // Attendre jusqu'à ce qu'une requête sorte de la fenêtre\n                const oldestRequest = Math.min(...this.requests);\n                const waitTime = this.timeWindow - (now - oldestRequest);\n                \n                if (waitTime > 0) {\n                    console.log(`Rate limiter: waiting ${waitTime}ms before next request`);\n                    await this.delay(waitTime);\n                    continue;\n                }\n            }\n\n            // Exécuter la prochaine requête\n            const { request, resolve, reject } = this.queue.shift();\n            this.requests.push(Date.now());\n\n            try {\n                const result = await request();\n                resolve(result);\n            } catch (error) {\n                reject(error);\n            }\n\n            // Petit délai entre les requêtes pour éviter de surcharger\n            await this.delay(50);\n        }\n\n        this.processing = false;\n    }\n\n    /**\n     * Utilitaire pour créer un délai\n     */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Réinitialise le limiteur\n     */\n    reset() {\n        this.requests = [];\n        this.queue = [];\n        this.processing = false;\n    }\n\n    /**\n     * Obtient les statistiques actuelles\n     */\n    getStats() {\n        const now = Date.now();\n        const recentRequests = this.requests.filter(\n            timestamp => now - timestamp < this.timeWindow\n        ).length;\n\n        return {\n            queueLength: this.queue.length,\n            recentRequests,\n            maxRequests: this.maxRequests,\n            canMakeRequest: recentRequests < this.maxRequests\n        };\n    }\n}\n\n// Instance globale du limiteur de débit\n// Limite à 5 requêtes par seconde pour être conservateur\nconst globalRateLimiter = new RateLimiter(5, 1000);\n\n/**\n * Fonction wrapper pour appliquer la limitation de débit à une requête\n */\nexport const withRateLimit = async (requestFunction) => {\n    return globalRateLimiter.execute(requestFunction);\n};\n\n/**\n * Hook React pour surveiller l'état du rate limiter\n */\n// export const useRateLimiterStats = () => {\n//     // Import dynamique pour éviter les dépendances circulaires\n//     if (typeof window !== 'undefined' && window.React) {\n//         // const { useState, useEffect } = window.React;\n//         const [stats, setStats] = useState(globalRateLimiter.getStats());\n\n//         useEffect(() => {\n//             const interval = setInterval(() => {\n//                 setStats(globalRateLimiter.getStats());\n//             }, 100);\n\n//             return () => clearInterval(interval);\n//         }, []);\n\n//         return stats;\n//     }\n    \n//     return globalRateLimiter.getStats();\n// };\n\nexport default globalRateLimiter;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}