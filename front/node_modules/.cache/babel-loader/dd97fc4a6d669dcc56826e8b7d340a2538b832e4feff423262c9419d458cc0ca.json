{"ast":null,"code":"import React from'react';/**\n * Gestionnaire sécurisé des tokens JWT\n * Fournit des fonctionnalités avancées pour la gestion des tokens\n */class TokenManager{constructor(){this.tokenKey='auth_token';this.refreshTokenKey='refresh_token';this.tokenPrefix='Bearer ';}/**\n     * Décode un token JWT sans vérification (côté client uniquement pour l'UI)\n     * ATTENTION: Ne jamais faire confiance au contenu côté client pour la sécurité\n     */decodeToken(token){try{if(!token)return null;const parts=token.split('.');if(parts.length!==3)return null;const payload=JSON.parse(atob(parts[1]));return payload;}catch(error){console.error('Erreur lors du décodage du token:',error);return null;}}/**\n     * Vérifie si un token est expiré\n     */isTokenExpired(token){let bufferSeconds=arguments.length>1&&arguments[1]!==undefined?arguments[1]:60;const payload=this.decodeToken(token);if(!payload||!payload.exp)return true;const currentTime=Math.floor(Date.now()/1000);const expirationTime=payload.exp-bufferSeconds;// Buffer de sécurité\nreturn currentTime>=expirationTime;}/**\n     * Obtient le temps restant avant expiration en secondes\n     */getTimeUntilExpiry(token){const payload=this.decodeToken(token);if(!payload||!payload.exp)return 0;const currentTime=Math.floor(Date.now()/1000);return Math.max(0,payload.exp-currentTime);}/**\n     * Obtient les informations utilisateur du token\n     */getUserFromToken(token){const payload=this.decodeToken(token);if(!payload)return null;return{id:payload.sub||payload.user_id||payload.id,username:payload.username||payload.preferred_username,email:payload.email,role:payload.role||payload.roles,permissions:payload.permissions||[],exp:payload.exp,iat:payload.iat};}/**\n     * Stockage sécurisé du token\n     */setToken(token){let remember=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{if(!token)return false;// Valider le format du token\nif(!this.isValidTokenFormat(token)){throw new Error('Format de token invalide');}const storage=remember?localStorage:sessionStorage;storage.setItem(this.tokenKey,token);// Marquer le type de stockage pour le retrieval\nstorage.setItem(`${this.tokenKey}_persistent`,remember.toString());return true;}catch(error){console.error('Erreur lors du stockage du token:',error);return false;}}/**\n     * Récupération sécurisée du token\n     */getToken(){try{// Essayer d'abord localStorage puis sessionStorage\nlet token=localStorage.getItem(this.tokenKey);let isPersistent=localStorage.getItem(`${this.tokenKey}_persistent`)==='true';if(!token){token=sessionStorage.getItem(this.tokenKey);isPersistent=false;}if(!token)return null;// Vérifier si le token est expiré\nif(this.isTokenExpired(token)){this.removeToken();return null;}return token;}catch(error){console.error('Erreur lors de la récupération du token:',error);return null;}}/**\n     * Suppression sécurisée du token\n     */removeToken(){try{localStorage.removeItem(this.tokenKey);localStorage.removeItem(`${this.tokenKey}_persistent`);localStorage.removeItem(this.refreshTokenKey);sessionStorage.removeItem(this.tokenKey);sessionStorage.removeItem(`${this.tokenKey}_persistent`);sessionStorage.removeItem(this.refreshTokenKey);return true;}catch(error){console.error('Erreur lors de la suppression du token:',error);return false;}}/**\n     * Validation du format du token JWT\n     */isValidTokenFormat(token){if(!token||typeof token!=='string')return false;// Un JWT doit avoir 3 parties séparées par des points\nconst parts=token.split('.');if(parts.length!==3)return false;// Vérifier que chaque partie est en base64\ntry{parts.forEach(part=>{atob(part);});return true;}catch(error){return false;}}/**\n     * Obtient le header d'autorisation formaté\n     */getAuthHeader(){const token=this.getToken();return token?`${this.tokenPrefix}${token}`:null;}/**\n     * Vérifie si l'utilisateur est authentifié\n     */isAuthenticated(){const token=this.getToken();return token&&!this.isTokenExpired(token);}/**\n     * Planifie le refresh automatique du token\n     */scheduleTokenRefresh(token,refreshCallback){let bufferMinutes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:5;if(!token||!refreshCallback)return null;const timeUntilExpiry=this.getTimeUntilExpiry(token);const refreshTime=Math.max(0,(timeUntilExpiry-bufferMinutes*60)*1000);if(refreshTime<=0){// Token déjà expiré ou sur le point d'expirer\nrefreshCallback();return null;}const timeoutId=setTimeout(()=>{refreshCallback();},refreshTime);console.log(`Token refresh planifié dans ${Math.floor(refreshTime/1000)} secondes`);return timeoutId;}/**\n     * Nettoie les timeouts de refresh\n     */clearTokenRefresh(timeoutId){if(timeoutId){clearTimeout(timeoutId);}}/**\n     * Gestion du refresh token (si supporté par le backend)\n     */setRefreshToken(refreshToken){try{if(refreshToken){localStorage.setItem(this.refreshTokenKey,refreshToken);return true;}return false;}catch(error){console.error('Erreur lors du stockage du refresh token:',error);return false;}}getRefreshToken(){try{return localStorage.getItem(this.refreshTokenKey);}catch(error){console.error('Erreur lors de la récupération du refresh token:',error);return null;}}/**\n     * Validation de sécurité côté client (ne pas faire confiance pour la sécurité réelle)\n     */validateTokenStructure(token){const payload=this.decodeToken(token);if(!payload)return false;// Vérifications basiques\nconst requiredFields=['exp','iat'];const hasRequiredFields=requiredFields.every(field=>payload.hasOwnProperty(field)&&payload[field]);if(!hasRequiredFields)return false;// Vérifier que iat (issued at) n'est pas dans le futur\nconst currentTime=Math.floor(Date.now()/1000);if(payload.iat>currentTime+60)return false;// Buffer de 60 secondes\n// Vérifier que exp (expiration) est après iat\nif(payload.exp<=payload.iat)return false;return true;}/**\n     * Obtient des informations de débogage sur le token\n     */getTokenInfo(){let token=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;const currentToken=token||this.getToken();if(!currentToken)return null;const payload=this.decodeToken(currentToken);if(!payload)return null;const currentTime=Math.floor(Date.now()/1000);return{isValid:this.validateTokenStructure(currentToken),isExpired:this.isTokenExpired(currentToken),timeUntilExpiry:this.getTimeUntilExpiry(currentToken),issuedAt:new Date(payload.iat*1000).toISOString(),expiresAt:new Date(payload.exp*1000).toISOString(),user:this.getUserFromToken(currentToken),rawPayload:payload};}}// Instance singleton\nexport const tokenManager=new TokenManager();// Hooks et utilitaires pour React\nexport const useTokenInfo=()=>{const[tokenInfo,setTokenInfo]=React.useState(null);React.useEffect(()=>{const updateTokenInfo=()=>{setTokenInfo(tokenManager.getTokenInfo());};updateTokenInfo();// Mettre à jour toutes les minutes\nconst interval=setInterval(updateTokenInfo,60000);return()=>clearInterval(interval);},[]);return tokenInfo;};export default tokenManager;","map":{"version":3,"names":["React","TokenManager","constructor","tokenKey","refreshTokenKey","tokenPrefix","decodeToken","token","parts","split","length","payload","JSON","parse","atob","error","console","isTokenExpired","bufferSeconds","arguments","undefined","exp","currentTime","Math","floor","Date","now","expirationTime","getTimeUntilExpiry","max","getUserFromToken","id","sub","user_id","username","preferred_username","email","role","roles","permissions","iat","setToken","remember","isValidTokenFormat","Error","storage","localStorage","sessionStorage","setItem","toString","getToken","getItem","isPersistent","removeToken","removeItem","forEach","part","getAuthHeader","isAuthenticated","scheduleTokenRefresh","refreshCallback","bufferMinutes","timeUntilExpiry","refreshTime","timeoutId","setTimeout","log","clearTokenRefresh","clearTimeout","setRefreshToken","refreshToken","getRefreshToken","validateTokenStructure","requiredFields","hasRequiredFields","every","field","hasOwnProperty","getTokenInfo","currentToken","isValid","isExpired","issuedAt","toISOString","expiresAt","user","rawPayload","tokenManager","useTokenInfo","tokenInfo","setTokenInfo","useState","useEffect","updateTokenInfo","interval","setInterval","clearInterval"],"sources":["/var/www/College-IUP/front/src/utils/tokenManager.js"],"sourcesContent":["import React from 'react';\n\n/**\n * Gestionnaire sécurisé des tokens JWT\n * Fournit des fonctionnalités avancées pour la gestion des tokens\n */\n\nclass TokenManager {\n    constructor() {\n        this.tokenKey = 'auth_token';\n        this.refreshTokenKey = 'refresh_token';\n        this.tokenPrefix = 'Bearer ';\n    }\n\n    /**\n     * Décode un token JWT sans vérification (côté client uniquement pour l'UI)\n     * ATTENTION: Ne jamais faire confiance au contenu côté client pour la sécurité\n     */\n    decodeToken(token) {\n        try {\n            if (!token) return null;\n            \n            const parts = token.split('.');\n            if (parts.length !== 3) return null;\n            \n            const payload = JSON.parse(atob(parts[1]));\n            return payload;\n        } catch (error) {\n            console.error('Erreur lors du décodage du token:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Vérifie si un token est expiré\n     */\n    isTokenExpired(token, bufferSeconds = 60) {\n        const payload = this.decodeToken(token);\n        if (!payload || !payload.exp) return true;\n        \n        const currentTime = Math.floor(Date.now() / 1000);\n        const expirationTime = payload.exp - bufferSeconds; // Buffer de sécurité\n        \n        return currentTime >= expirationTime;\n    }\n\n    /**\n     * Obtient le temps restant avant expiration en secondes\n     */\n    getTimeUntilExpiry(token) {\n        const payload = this.decodeToken(token);\n        if (!payload || !payload.exp) return 0;\n        \n        const currentTime = Math.floor(Date.now() / 1000);\n        return Math.max(0, payload.exp - currentTime);\n    }\n\n    /**\n     * Obtient les informations utilisateur du token\n     */\n    getUserFromToken(token) {\n        const payload = this.decodeToken(token);\n        if (!payload) return null;\n        \n        return {\n            id: payload.sub || payload.user_id || payload.id,\n            username: payload.username || payload.preferred_username,\n            email: payload.email,\n            role: payload.role || payload.roles,\n            permissions: payload.permissions || [],\n            exp: payload.exp,\n            iat: payload.iat\n        };\n    }\n\n    /**\n     * Stockage sécurisé du token\n     */\n    setToken(token, remember = false) {\n        try {\n            if (!token) return false;\n            \n            // Valider le format du token\n            if (!this.isValidTokenFormat(token)) {\n                throw new Error('Format de token invalide');\n            }\n            \n            const storage = remember ? localStorage : sessionStorage;\n            storage.setItem(this.tokenKey, token);\n            \n            // Marquer le type de stockage pour le retrieval\n            storage.setItem(`${this.tokenKey}_persistent`, remember.toString());\n            \n            return true;\n        } catch (error) {\n            console.error('Erreur lors du stockage du token:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Récupération sécurisée du token\n     */\n    getToken() {\n        try {\n            // Essayer d'abord localStorage puis sessionStorage\n            let token = localStorage.getItem(this.tokenKey);\n            let isPersistent = localStorage.getItem(`${this.tokenKey}_persistent`) === 'true';\n            \n            if (!token) {\n                token = sessionStorage.getItem(this.tokenKey);\n                isPersistent = false;\n            }\n            \n            if (!token) return null;\n            \n            // Vérifier si le token est expiré\n            if (this.isTokenExpired(token)) {\n                this.removeToken();\n                return null;\n            }\n            \n            return token;\n        } catch (error) {\n            console.error('Erreur lors de la récupération du token:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Suppression sécurisée du token\n     */\n    removeToken() {\n        try {\n            localStorage.removeItem(this.tokenKey);\n            localStorage.removeItem(`${this.tokenKey}_persistent`);\n            localStorage.removeItem(this.refreshTokenKey);\n            \n            sessionStorage.removeItem(this.tokenKey);\n            sessionStorage.removeItem(`${this.tokenKey}_persistent`);\n            sessionStorage.removeItem(this.refreshTokenKey);\n            \n            return true;\n        } catch (error) {\n            console.error('Erreur lors de la suppression du token:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Validation du format du token JWT\n     */\n    isValidTokenFormat(token) {\n        if (!token || typeof token !== 'string') return false;\n        \n        // Un JWT doit avoir 3 parties séparées par des points\n        const parts = token.split('.');\n        if (parts.length !== 3) return false;\n        \n        // Vérifier que chaque partie est en base64\n        try {\n            parts.forEach(part => {\n                atob(part);\n            });\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Obtient le header d'autorisation formaté\n     */\n    getAuthHeader() {\n        const token = this.getToken();\n        return token ? `${this.tokenPrefix}${token}` : null;\n    }\n\n    /**\n     * Vérifie si l'utilisateur est authentifié\n     */\n    isAuthenticated() {\n        const token = this.getToken();\n        return token && !this.isTokenExpired(token);\n    }\n\n    /**\n     * Planifie le refresh automatique du token\n     */\n    scheduleTokenRefresh(token, refreshCallback, bufferMinutes = 5) {\n        if (!token || !refreshCallback) return null;\n        \n        const timeUntilExpiry = this.getTimeUntilExpiry(token);\n        const refreshTime = Math.max(0, (timeUntilExpiry - (bufferMinutes * 60)) * 1000);\n        \n        if (refreshTime <= 0) {\n            // Token déjà expiré ou sur le point d'expirer\n            refreshCallback();\n            return null;\n        }\n        \n        const timeoutId = setTimeout(() => {\n            refreshCallback();\n        }, refreshTime);\n        \n        console.log(`Token refresh planifié dans ${Math.floor(refreshTime / 1000)} secondes`);\n        return timeoutId;\n    }\n\n    /**\n     * Nettoie les timeouts de refresh\n     */\n    clearTokenRefresh(timeoutId) {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    /**\n     * Gestion du refresh token (si supporté par le backend)\n     */\n    setRefreshToken(refreshToken) {\n        try {\n            if (refreshToken) {\n                localStorage.setItem(this.refreshTokenKey, refreshToken);\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.error('Erreur lors du stockage du refresh token:', error);\n            return false;\n        }\n    }\n\n    getRefreshToken() {\n        try {\n            return localStorage.getItem(this.refreshTokenKey);\n        } catch (error) {\n            console.error('Erreur lors de la récupération du refresh token:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Validation de sécurité côté client (ne pas faire confiance pour la sécurité réelle)\n     */\n    validateTokenStructure(token) {\n        const payload = this.decodeToken(token);\n        if (!payload) return false;\n        \n        // Vérifications basiques\n        const requiredFields = ['exp', 'iat'];\n        const hasRequiredFields = requiredFields.every(field => \n            payload.hasOwnProperty(field) && payload[field]\n        );\n        \n        if (!hasRequiredFields) return false;\n        \n        // Vérifier que iat (issued at) n'est pas dans le futur\n        const currentTime = Math.floor(Date.now() / 1000);\n        if (payload.iat > currentTime + 60) return false; // Buffer de 60 secondes\n        \n        // Vérifier que exp (expiration) est après iat\n        if (payload.exp <= payload.iat) return false;\n        \n        return true;\n    }\n\n    /**\n     * Obtient des informations de débogage sur le token\n     */\n    getTokenInfo(token = null) {\n        const currentToken = token || this.getToken();\n        if (!currentToken) return null;\n        \n        const payload = this.decodeToken(currentToken);\n        if (!payload) return null;\n        \n        const currentTime = Math.floor(Date.now() / 1000);\n        \n        return {\n            isValid: this.validateTokenStructure(currentToken),\n            isExpired: this.isTokenExpired(currentToken),\n            timeUntilExpiry: this.getTimeUntilExpiry(currentToken),\n            issuedAt: new Date(payload.iat * 1000).toISOString(),\n            expiresAt: new Date(payload.exp * 1000).toISOString(),\n            user: this.getUserFromToken(currentToken),\n            rawPayload: payload\n        };\n    }\n}\n\n// Instance singleton\nexport const tokenManager = new TokenManager();\n\n// Hooks et utilitaires pour React\nexport const useTokenInfo = () => {\n    const [tokenInfo, setTokenInfo] = React.useState(null);\n    \n    React.useEffect(() => {\n        const updateTokenInfo = () => {\n            setTokenInfo(tokenManager.getTokenInfo());\n        };\n        \n        updateTokenInfo();\n        \n        // Mettre à jour toutes les minutes\n        const interval = setInterval(updateTokenInfo, 60000);\n        \n        return () => clearInterval(interval);\n    }, []);\n    \n    return tokenInfo;\n};\n\nexport default tokenManager;"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CAEzB;AACA;AACA;AACA,GAEA,KAAM,CAAAC,YAAa,CACfC,WAAWA,CAAA,CAAG,CACV,IAAI,CAACC,QAAQ,CAAG,YAAY,CAC5B,IAAI,CAACC,eAAe,CAAG,eAAe,CACtC,IAAI,CAACC,WAAW,CAAG,SAAS,CAChC,CAEA;AACJ;AACA;AACA,OACIC,WAAWA,CAACC,KAAK,CAAE,CACf,GAAI,CACA,GAAI,CAACA,KAAK,CAAE,MAAO,KAAI,CAEvB,KAAM,CAAAC,KAAK,CAAGD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC,CAC9B,GAAID,KAAK,CAACE,MAAM,GAAK,CAAC,CAAE,MAAO,KAAI,CAEnC,KAAM,CAAAC,OAAO,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC1C,MAAO,CAAAG,OAAO,CAClB,CAAE,MAAOI,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,MAAO,KAAI,CACf,CACJ,CAEA;AACJ;AACA,OACIE,cAAcA,CAACV,KAAK,CAAsB,IAApB,CAAAW,aAAa,CAAAC,SAAA,CAAAT,MAAA,IAAAS,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,EAAE,CACpC,KAAM,CAAAR,OAAO,CAAG,IAAI,CAACL,WAAW,CAACC,KAAK,CAAC,CACvC,GAAI,CAACI,OAAO,EAAI,CAACA,OAAO,CAACU,GAAG,CAAE,MAAO,KAAI,CAEzC,KAAM,CAAAC,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CACjD,KAAM,CAAAC,cAAc,CAAGhB,OAAO,CAACU,GAAG,CAAGH,aAAa,CAAE;AAEpD,MAAO,CAAAI,WAAW,EAAIK,cAAc,CACxC,CAEA;AACJ;AACA,OACIC,kBAAkBA,CAACrB,KAAK,CAAE,CACtB,KAAM,CAAAI,OAAO,CAAG,IAAI,CAACL,WAAW,CAACC,KAAK,CAAC,CACvC,GAAI,CAACI,OAAO,EAAI,CAACA,OAAO,CAACU,GAAG,CAAE,MAAO,EAAC,CAEtC,KAAM,CAAAC,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CACjD,MAAO,CAAAH,IAAI,CAACM,GAAG,CAAC,CAAC,CAAElB,OAAO,CAACU,GAAG,CAAGC,WAAW,CAAC,CACjD,CAEA;AACJ;AACA,OACIQ,gBAAgBA,CAACvB,KAAK,CAAE,CACpB,KAAM,CAAAI,OAAO,CAAG,IAAI,CAACL,WAAW,CAACC,KAAK,CAAC,CACvC,GAAI,CAACI,OAAO,CAAE,MAAO,KAAI,CAEzB,MAAO,CACHoB,EAAE,CAAEpB,OAAO,CAACqB,GAAG,EAAIrB,OAAO,CAACsB,OAAO,EAAItB,OAAO,CAACoB,EAAE,CAChDG,QAAQ,CAAEvB,OAAO,CAACuB,QAAQ,EAAIvB,OAAO,CAACwB,kBAAkB,CACxDC,KAAK,CAAEzB,OAAO,CAACyB,KAAK,CACpBC,IAAI,CAAE1B,OAAO,CAAC0B,IAAI,EAAI1B,OAAO,CAAC2B,KAAK,CACnCC,WAAW,CAAE5B,OAAO,CAAC4B,WAAW,EAAI,EAAE,CACtClB,GAAG,CAAEV,OAAO,CAACU,GAAG,CAChBmB,GAAG,CAAE7B,OAAO,CAAC6B,GACjB,CAAC,CACL,CAEA;AACJ;AACA,OACIC,QAAQA,CAAClC,KAAK,CAAoB,IAAlB,CAAAmC,QAAQ,CAAAvB,SAAA,CAAAT,MAAA,IAAAS,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,KAAK,CAC5B,GAAI,CACA,GAAI,CAACZ,KAAK,CAAE,MAAO,MAAK,CAExB;AACA,GAAI,CAAC,IAAI,CAACoC,kBAAkB,CAACpC,KAAK,CAAC,CAAE,CACjC,KAAM,IAAI,CAAAqC,KAAK,CAAC,0BAA0B,CAAC,CAC/C,CAEA,KAAM,CAAAC,OAAO,CAAGH,QAAQ,CAAGI,YAAY,CAAGC,cAAc,CACxDF,OAAO,CAACG,OAAO,CAAC,IAAI,CAAC7C,QAAQ,CAAEI,KAAK,CAAC,CAErC;AACAsC,OAAO,CAACG,OAAO,CAAC,GAAG,IAAI,CAAC7C,QAAQ,aAAa,CAAEuC,QAAQ,CAACO,QAAQ,CAAC,CAAC,CAAC,CAEnE,MAAO,KAAI,CACf,CAAE,MAAOlC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,MAAO,MAAK,CAChB,CACJ,CAEA;AACJ;AACA,OACImC,QAAQA,CAAA,CAAG,CACP,GAAI,CACA;AACA,GAAI,CAAA3C,KAAK,CAAGuC,YAAY,CAACK,OAAO,CAAC,IAAI,CAAChD,QAAQ,CAAC,CAC/C,GAAI,CAAAiD,YAAY,CAAGN,YAAY,CAACK,OAAO,CAAC,GAAG,IAAI,CAAChD,QAAQ,aAAa,CAAC,GAAK,MAAM,CAEjF,GAAI,CAACI,KAAK,CAAE,CACRA,KAAK,CAAGwC,cAAc,CAACI,OAAO,CAAC,IAAI,CAAChD,QAAQ,CAAC,CAC7CiD,YAAY,CAAG,KAAK,CACxB,CAEA,GAAI,CAAC7C,KAAK,CAAE,MAAO,KAAI,CAEvB;AACA,GAAI,IAAI,CAACU,cAAc,CAACV,KAAK,CAAC,CAAE,CAC5B,IAAI,CAAC8C,WAAW,CAAC,CAAC,CAClB,MAAO,KAAI,CACf,CAEA,MAAO,CAAA9C,KAAK,CAChB,CAAE,MAAOQ,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,0CAA0C,CAAEA,KAAK,CAAC,CAChE,MAAO,KAAI,CACf,CACJ,CAEA;AACJ;AACA,OACIsC,WAAWA,CAAA,CAAG,CACV,GAAI,CACAP,YAAY,CAACQ,UAAU,CAAC,IAAI,CAACnD,QAAQ,CAAC,CACtC2C,YAAY,CAACQ,UAAU,CAAC,GAAG,IAAI,CAACnD,QAAQ,aAAa,CAAC,CACtD2C,YAAY,CAACQ,UAAU,CAAC,IAAI,CAAClD,eAAe,CAAC,CAE7C2C,cAAc,CAACO,UAAU,CAAC,IAAI,CAACnD,QAAQ,CAAC,CACxC4C,cAAc,CAACO,UAAU,CAAC,GAAG,IAAI,CAACnD,QAAQ,aAAa,CAAC,CACxD4C,cAAc,CAACO,UAAU,CAAC,IAAI,CAAClD,eAAe,CAAC,CAE/C,MAAO,KAAI,CACf,CAAE,MAAOW,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,yCAAyC,CAAEA,KAAK,CAAC,CAC/D,MAAO,MAAK,CAChB,CACJ,CAEA;AACJ;AACA,OACI4B,kBAAkBA,CAACpC,KAAK,CAAE,CACtB,GAAI,CAACA,KAAK,EAAI,MAAO,CAAAA,KAAK,GAAK,QAAQ,CAAE,MAAO,MAAK,CAErD;AACA,KAAM,CAAAC,KAAK,CAAGD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC,CAC9B,GAAID,KAAK,CAACE,MAAM,GAAK,CAAC,CAAE,MAAO,MAAK,CAEpC;AACA,GAAI,CACAF,KAAK,CAAC+C,OAAO,CAACC,IAAI,EAAI,CAClB1C,IAAI,CAAC0C,IAAI,CAAC,CACd,CAAC,CAAC,CACF,MAAO,KAAI,CACf,CAAE,MAAOzC,KAAK,CAAE,CACZ,MAAO,MAAK,CAChB,CACJ,CAEA;AACJ;AACA,OACI0C,aAAaA,CAAA,CAAG,CACZ,KAAM,CAAAlD,KAAK,CAAG,IAAI,CAAC2C,QAAQ,CAAC,CAAC,CAC7B,MAAO,CAAA3C,KAAK,CAAG,GAAG,IAAI,CAACF,WAAW,GAAGE,KAAK,EAAE,CAAG,IAAI,CACvD,CAEA;AACJ;AACA,OACImD,eAAeA,CAAA,CAAG,CACd,KAAM,CAAAnD,KAAK,CAAG,IAAI,CAAC2C,QAAQ,CAAC,CAAC,CAC7B,MAAO,CAAA3C,KAAK,EAAI,CAAC,IAAI,CAACU,cAAc,CAACV,KAAK,CAAC,CAC/C,CAEA;AACJ;AACA,OACIoD,oBAAoBA,CAACpD,KAAK,CAAEqD,eAAe,CAAqB,IAAnB,CAAAC,aAAa,CAAA1C,SAAA,CAAAT,MAAA,IAAAS,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,CAAC,CAC1D,GAAI,CAACZ,KAAK,EAAI,CAACqD,eAAe,CAAE,MAAO,KAAI,CAE3C,KAAM,CAAAE,eAAe,CAAG,IAAI,CAAClC,kBAAkB,CAACrB,KAAK,CAAC,CACtD,KAAM,CAAAwD,WAAW,CAAGxC,IAAI,CAACM,GAAG,CAAC,CAAC,CAAE,CAACiC,eAAe,CAAID,aAAa,CAAG,EAAG,EAAI,IAAI,CAAC,CAEhF,GAAIE,WAAW,EAAI,CAAC,CAAE,CAClB;AACAH,eAAe,CAAC,CAAC,CACjB,MAAO,KAAI,CACf,CAEA,KAAM,CAAAI,SAAS,CAAGC,UAAU,CAAC,IAAM,CAC/BL,eAAe,CAAC,CAAC,CACrB,CAAC,CAAEG,WAAW,CAAC,CAEf/C,OAAO,CAACkD,GAAG,CAAC,+BAA+B3C,IAAI,CAACC,KAAK,CAACuC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAC,CACrF,MAAO,CAAAC,SAAS,CACpB,CAEA;AACJ;AACA,OACIG,iBAAiBA,CAACH,SAAS,CAAE,CACzB,GAAIA,SAAS,CAAE,CACXI,YAAY,CAACJ,SAAS,CAAC,CAC3B,CACJ,CAEA;AACJ;AACA,OACIK,eAAeA,CAACC,YAAY,CAAE,CAC1B,GAAI,CACA,GAAIA,YAAY,CAAE,CACdxB,YAAY,CAACE,OAAO,CAAC,IAAI,CAAC5C,eAAe,CAAEkE,YAAY,CAAC,CACxD,MAAO,KAAI,CACf,CACA,MAAO,MAAK,CAChB,CAAE,MAAOvD,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,2CAA2C,CAAEA,KAAK,CAAC,CACjE,MAAO,MAAK,CAChB,CACJ,CAEAwD,eAAeA,CAAA,CAAG,CACd,GAAI,CACA,MAAO,CAAAzB,YAAY,CAACK,OAAO,CAAC,IAAI,CAAC/C,eAAe,CAAC,CACrD,CAAE,MAAOW,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,kDAAkD,CAAEA,KAAK,CAAC,CACxE,MAAO,KAAI,CACf,CACJ,CAEA;AACJ;AACA,OACIyD,sBAAsBA,CAACjE,KAAK,CAAE,CAC1B,KAAM,CAAAI,OAAO,CAAG,IAAI,CAACL,WAAW,CAACC,KAAK,CAAC,CACvC,GAAI,CAACI,OAAO,CAAE,MAAO,MAAK,CAE1B;AACA,KAAM,CAAA8D,cAAc,CAAG,CAAC,KAAK,CAAE,KAAK,CAAC,CACrC,KAAM,CAAAC,iBAAiB,CAAGD,cAAc,CAACE,KAAK,CAACC,KAAK,EAChDjE,OAAO,CAACkE,cAAc,CAACD,KAAK,CAAC,EAAIjE,OAAO,CAACiE,KAAK,CAClD,CAAC,CAED,GAAI,CAACF,iBAAiB,CAAE,MAAO,MAAK,CAEpC;AACA,KAAM,CAAApD,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CACjD,GAAIf,OAAO,CAAC6B,GAAG,CAAGlB,WAAW,CAAG,EAAE,CAAE,MAAO,MAAK,CAAE;AAElD;AACA,GAAIX,OAAO,CAACU,GAAG,EAAIV,OAAO,CAAC6B,GAAG,CAAE,MAAO,MAAK,CAE5C,MAAO,KAAI,CACf,CAEA;AACJ;AACA,OACIsC,YAAYA,CAAA,CAAe,IAAd,CAAAvE,KAAK,CAAAY,SAAA,CAAAT,MAAA,IAAAS,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,IAAI,CACrB,KAAM,CAAA4D,YAAY,CAAGxE,KAAK,EAAI,IAAI,CAAC2C,QAAQ,CAAC,CAAC,CAC7C,GAAI,CAAC6B,YAAY,CAAE,MAAO,KAAI,CAE9B,KAAM,CAAApE,OAAO,CAAG,IAAI,CAACL,WAAW,CAACyE,YAAY,CAAC,CAC9C,GAAI,CAACpE,OAAO,CAAE,MAAO,KAAI,CAEzB,KAAM,CAAAW,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CAEjD,MAAO,CACHsD,OAAO,CAAE,IAAI,CAACR,sBAAsB,CAACO,YAAY,CAAC,CAClDE,SAAS,CAAE,IAAI,CAAChE,cAAc,CAAC8D,YAAY,CAAC,CAC5CjB,eAAe,CAAE,IAAI,CAAClC,kBAAkB,CAACmD,YAAY,CAAC,CACtDG,QAAQ,CAAE,GAAI,CAAAzD,IAAI,CAACd,OAAO,CAAC6B,GAAG,CAAG,IAAI,CAAC,CAAC2C,WAAW,CAAC,CAAC,CACpDC,SAAS,CAAE,GAAI,CAAA3D,IAAI,CAACd,OAAO,CAACU,GAAG,CAAG,IAAI,CAAC,CAAC8D,WAAW,CAAC,CAAC,CACrDE,IAAI,CAAE,IAAI,CAACvD,gBAAgB,CAACiD,YAAY,CAAC,CACzCO,UAAU,CAAE3E,OAChB,CAAC,CACL,CACJ,CAEA;AACA,MAAO,MAAM,CAAA4E,YAAY,CAAG,GAAI,CAAAtF,YAAY,CAAC,CAAC,CAE9C;AACA,MAAO,MAAM,CAAAuF,YAAY,CAAGA,CAAA,GAAM,CAC9B,KAAM,CAACC,SAAS,CAAEC,YAAY,CAAC,CAAG1F,KAAK,CAAC2F,QAAQ,CAAC,IAAI,CAAC,CAEtD3F,KAAK,CAAC4F,SAAS,CAAC,IAAM,CAClB,KAAM,CAAAC,eAAe,CAAGA,CAAA,GAAM,CAC1BH,YAAY,CAACH,YAAY,CAACT,YAAY,CAAC,CAAC,CAAC,CAC7C,CAAC,CAEDe,eAAe,CAAC,CAAC,CAEjB;AACA,KAAM,CAAAC,QAAQ,CAAGC,WAAW,CAACF,eAAe,CAAE,KAAK,CAAC,CAEpD,MAAO,IAAMG,aAAa,CAACF,QAAQ,CAAC,CACxC,CAAC,CAAE,EAAE,CAAC,CAEN,MAAO,CAAAL,SAAS,CACpB,CAAC,CAED,cAAe,CAAAF,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}