{"ast":null,"code":"import{host}from'../utils/fetch';import logger from'../utils/logger';class AuthService{constructor(){this.baseURL=`${host}/api/auth`;this.tokenKey='auth_token';this.userKey='user_data';}// Configuration des headers par défaut\ngetHeaders(){let includeAuth=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;const headers={'Content-Type':'application/json','Accept':'application/json'};if(includeAuth){const token=this.getToken();if(token){headers['Authorization']=`Bearer ${token}`;}}return headers;}// Gestion sécurisée du stockage des tokens\nsetToken(token){try{// Utiliser localStorage pour la persistance (plus sécurisé que sessionStorage pour les tokens)\nlocalStorage.setItem(this.tokenKey,token);// Optionnel: chiffrer le token avant stockage pour plus de sécurité\n// const encryptedToken = this.encryptToken(token);\n// localStorage.setItem(this.tokenKey, encryptedToken);\n}catch(error){console.error('Erreur lors du stockage du token:',error);}}getToken(){try{const token=localStorage.getItem(this.tokenKey);// Optionnel: déchiffrer le token si chiffré\n// return token ? this.decryptToken(token) : null;\nreturn token;}catch(error){console.error('Erreur lors de la récupération du token:',error);return null;}}removeToken(){try{localStorage.removeItem(this.tokenKey);localStorage.removeItem(this.userKey);sessionStorage.clear();// Nettoyer aussi sessionStorage\n}catch(error){console.error('Erreur lors de la suppression du token:',error);}}// Vérifier si le token est expiré\nisTokenExpired(){let token=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;const currentToken=token||this.getToken();if(!currentToken)return true;try{const payload=JSON.parse(atob(currentToken.split('.')[1]));const currentTime=Math.floor(Date.now()/1000);// Vérifier si le token expire dans les 5 prochaines minutes\nreturn payload.exp<currentTime+300;}catch(error){console.error('Erreur lors de la vérification du token:',error);return true;}}// Fonction de requête avec gestion d'erreurs\nasync makeRequest(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const fullUrl=url.startsWith('http')?url:`${this.baseURL}${url}`;try{const response=await fetch(fullUrl,{...options,headers:{...this.getHeaders(options.includeAuth!==false),...options.headers}});// Gestion des erreurs HTTP\nif(!response.ok){const errorData=await response.json().catch(()=>({}));// Gestion spéciale pour les erreurs 401\nif(response.status===401){// Ne déclencher la déconnexion automatique que pour les requêtes authentifiées\n// Pas pour les tentatives de login (qui ont includeAuth = false)\nif(options.includeAuth!==false){this.removeToken();window.dispatchEvent(new CustomEvent('auth:unauthorized'));throw new Error('Session expirée. Veuillez vous reconnecter.');}// Pour les erreurs de login, laisser passer l'erreur normale\n}throw new Error(errorData.message||errorData.error||`Erreur HTTP ${response.status}: ${response.statusText}`);}return await response.json();}catch(error){if(error.name==='TypeError'&&error.message.includes('fetch')){throw new Error('Impossible de se connecter au serveur. Vérifiez votre connexion.');}throw error;}}// Connexion utilisateur\nasync login(credentials){try{const response=await this.makeRequest('/login',{method:'POST',body:JSON.stringify({username:credentials.username.trim(),password:credentials.password}),includeAuth:false});if(response.access_token&&response.user){// Stocker le token et les informations utilisateur\nthis.setToken(response.access_token);localStorage.setItem(this.userKey,JSON.stringify(response.user));return response;}else{throw new Error('Réponse invalide du serveur');}}catch(error){console.error('Erreur de connexion:',error);throw error;}}// Inscription utilisateur (si nécessaire)\nasync register(userData){try{const response=await this.makeRequest('/register',{method:'POST',body:JSON.stringify(userData),includeAuth:false});return response;}catch(error){console.error('Erreur d\\'inscription:',error);throw error;}}// Déconnexion\nasync logout(){try{await this.makeRequest('/logout',{method:'POST'});}catch(error){console.error('Erreur lors de la déconnexion:',error);// Continuer la déconnexion même en cas d'erreur serveur\n}finally{this.removeToken();}}// Refresh du token\nasync refreshToken(){try{const response=await this.makeRequest('/refresh',{method:'POST'});if(response.access_token){// Mettre à jour les informations utilisateur si présentes\nif(response.user){localStorage.setItem(this.userKey,JSON.stringify(response.user));}return response;}else{throw new Error('Impossible de renouveler le token');}}catch(error){console.error('Erreur lors du refresh du token:',error);this.removeToken();throw error;}}// Obtenir les informations de l'utilisateur actuel\nasync getCurrentUser(){try{const response=await this.makeRequest('/me',{method:'GET'});if(response){localStorage.setItem(this.userKey,JSON.stringify(response));return response;}else{throw new Error('Impossible de récupérer les informations utilisateur');}}catch(error){logger.apiError(error,'getCurrentUser');throw error;}}// Obtenir les données utilisateur du cache local\ngetCachedUser(){try{const userData=localStorage.getItem(this.userKey);return userData?JSON.parse(userData):null;}catch(error){console.error('Erreur lors de la récupération des données utilisateur en cache:',error);return null;}}// Vérifier si l'utilisateur est authentifié\nisAuthenticated(){const token=this.getToken();return token&&!this.isTokenExpired(token);}// Obtenir le rôle de l'utilisateur\ngetUserRole(){const user=this.getCachedUser();return(user===null||user===void 0?void 0:user.role)||null;}// Vérifier si l'utilisateur a un rôle spécifique\nhasRole(role){return this.getUserRole()===role;}// Vérifier si l'utilisateur a l'un des rôles spécifiés\nhasAnyRole(roles){const userRole=this.getUserRole();return roles.includes(userRole);}// Intercepteur pour les requêtes automatiques\nsetupInterceptors(){var _this=this;// Intercepter toutes les requêtes fetch pour ajouter automatiquement le token\nconst originalFetch=window.fetch;window.fetch=async function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Vérifier si c'est une requête vers notre API\nif(url.includes(host)||url.startsWith('/api')){const token=_this.getToken();if(token&&!_this.isTokenExpired(token)){options.headers={...options.headers,'Authorization':`Bearer ${token}`};}}return originalFetch(url,options);};}// Restaurer les intercepteurs (si nécessaire)\nrestoreInterceptors(){// Restaurer le fetch original si modifié\nif(window.originalFetch){window.fetch=window.originalFetch;delete window.originalFetch;}}}// Instance singleton du service d'authentification\nexport const authService=new AuthService();// Initialiser les intercepteurs au chargement\nif(typeof window!=='undefined'){authService.setupInterceptors();}export default authService;","map":{"version":3,"names":["host","logger","AuthService","constructor","baseURL","tokenKey","userKey","getHeaders","includeAuth","arguments","length","undefined","headers","token","getToken","setToken","localStorage","setItem","error","console","getItem","removeToken","removeItem","sessionStorage","clear","isTokenExpired","currentToken","payload","JSON","parse","atob","split","currentTime","Math","floor","Date","now","exp","makeRequest","url","options","fullUrl","startsWith","response","fetch","ok","errorData","json","catch","status","window","dispatchEvent","CustomEvent","Error","message","statusText","name","includes","login","credentials","method","body","stringify","username","trim","password","access_token","user","register","userData","logout","refreshToken","getCurrentUser","apiError","getCachedUser","isAuthenticated","getUserRole","role","hasRole","hasAnyRole","roles","userRole","setupInterceptors","_this","originalFetch","restoreInterceptors","authService"],"sources":["/var/www/College-IUP/front/src/services/authService.js"],"sourcesContent":["import { host } from '../utils/fetch';\nimport logger from '../utils/logger';\n\nclass AuthService {\n    constructor() {\n        this.baseURL = `${host}/api/auth`;\n        this.tokenKey = 'auth_token';\n        this.userKey = 'user_data';\n    }\n\n    // Configuration des headers par défaut\n    getHeaders(includeAuth = true) {\n        const headers = {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json'\n        };\n\n        if (includeAuth) {\n            const token = this.getToken();\n            if (token) {\n                headers['Authorization'] = `Bearer ${token}`;\n            }\n        }\n\n        return headers;\n    }\n\n    // Gestion sécurisée du stockage des tokens\n    setToken(token) {\n        try {\n            // Utiliser localStorage pour la persistance (plus sécurisé que sessionStorage pour les tokens)\n            localStorage.setItem(this.tokenKey, token);\n            \n            // Optionnel: chiffrer le token avant stockage pour plus de sécurité\n            // const encryptedToken = this.encryptToken(token);\n            // localStorage.setItem(this.tokenKey, encryptedToken);\n        } catch (error) {\n            console.error('Erreur lors du stockage du token:', error);\n        }\n    }\n\n    getToken() {\n        try {\n            const token = localStorage.getItem(this.tokenKey);\n            // Optionnel: déchiffrer le token si chiffré\n            // return token ? this.decryptToken(token) : null;\n            return token;\n        } catch (error) {\n            console.error('Erreur lors de la récupération du token:', error);\n            return null;\n        }\n    }\n\n    removeToken() {\n        try {\n            localStorage.removeItem(this.tokenKey);\n            localStorage.removeItem(this.userKey);\n            sessionStorage.clear(); // Nettoyer aussi sessionStorage\n        } catch (error) {\n            console.error('Erreur lors de la suppression du token:', error);\n        }\n    }\n\n    // Vérifier si le token est expiré\n    isTokenExpired(token = null) {\n        const currentToken = token || this.getToken();\n        \n        if (!currentToken) return true;\n\n        try {\n            const payload = JSON.parse(atob(currentToken.split('.')[1]));\n            const currentTime = Math.floor(Date.now() / 1000);\n            \n            // Vérifier si le token expire dans les 5 prochaines minutes\n            return payload.exp < (currentTime + 300);\n        } catch (error) {\n            console.error('Erreur lors de la vérification du token:', error);\n            return true;\n        }\n    }\n\n    // Fonction de requête avec gestion d'erreurs\n    async makeRequest(url, options = {}) {\n        const fullUrl = url.startsWith('http') ? url : `${this.baseURL}${url}`;\n        \n        try {\n            const response = await fetch(fullUrl, {\n                ...options,\n                headers: {\n                    ...this.getHeaders(options.includeAuth !== false),\n                    ...options.headers\n                }\n            });\n\n            // Gestion des erreurs HTTP\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({}));\n                \n                // Gestion spéciale pour les erreurs 401\n                if (response.status === 401) {\n                    // Ne déclencher la déconnexion automatique que pour les requêtes authentifiées\n                    // Pas pour les tentatives de login (qui ont includeAuth = false)\n                    if (options.includeAuth !== false) {\n                        this.removeToken();\n                        window.dispatchEvent(new CustomEvent('auth:unauthorized'));\n                        throw new Error('Session expirée. Veuillez vous reconnecter.');\n                    }\n                    // Pour les erreurs de login, laisser passer l'erreur normale\n                }\n                \n                throw new Error(\n                    errorData.message || \n                    errorData.error || \n                    `Erreur HTTP ${response.status}: ${response.statusText}`\n                );\n            }\n\n            return await response.json();\n        } catch (error) {\n            if (error.name === 'TypeError' && error.message.includes('fetch')) {\n                throw new Error('Impossible de se connecter au serveur. Vérifiez votre connexion.');\n            }\n            throw error;\n        }\n    }\n\n    // Connexion utilisateur\n    async login(credentials) {\n        try {\n            const response = await this.makeRequest('/login', {\n                method: 'POST',\n                body: JSON.stringify({\n                    username: credentials.username.trim(),\n                    password: credentials.password\n                }),\n                includeAuth: false\n            });\n\n            if (response.access_token && response.user) {\n                // Stocker le token et les informations utilisateur\n                this.setToken(response.access_token);\n                localStorage.setItem(this.userKey, JSON.stringify(response.user));\n                \n                return response;\n            } else {\n                throw new Error('Réponse invalide du serveur');\n            }\n        } catch (error) {\n            console.error('Erreur de connexion:', error);\n            throw error;\n        }\n    }\n\n    // Inscription utilisateur (si nécessaire)\n    async register(userData) {\n        try {\n            const response = await this.makeRequest('/register', {\n                method: 'POST',\n                body: JSON.stringify(userData),\n                includeAuth: false\n            });\n\n            return response;\n        } catch (error) {\n            console.error('Erreur d\\'inscription:', error);\n            throw error;\n        }\n    }\n\n    // Déconnexion\n    async logout() {\n        try {\n            await this.makeRequest('/logout', {\n                method: 'POST'\n            });\n        } catch (error) {\n            console.error('Erreur lors de la déconnexion:', error);\n            // Continuer la déconnexion même en cas d'erreur serveur\n        } finally {\n            this.removeToken();\n        }\n    }\n\n    // Refresh du token\n    async refreshToken() {\n        try {\n            const response = await this.makeRequest('/refresh', {\n                method: 'POST'\n            });\n\n            if (response.access_token) {\n                // Mettre à jour les informations utilisateur si présentes\n                if (response.user) {\n                    localStorage.setItem(this.userKey, JSON.stringify(response.user));\n                }\n                \n                return response;\n            } else {\n                throw new Error('Impossible de renouveler le token');\n            }\n        } catch (error) {\n            console.error('Erreur lors du refresh du token:', error);\n            this.removeToken();\n            throw error;\n        }\n    }\n\n    // Obtenir les informations de l'utilisateur actuel\n    async getCurrentUser() {\n        try {\n            const response = await this.makeRequest('/me', {\n                method: 'GET'\n            });\n\n            if (response) {\n                localStorage.setItem(this.userKey, JSON.stringify(response));\n                return response;\n            } else {\n                throw new Error('Impossible de récupérer les informations utilisateur');\n            }\n        } catch (error) {\n            logger.apiError(error, 'getCurrentUser');\n            throw error;\n        }\n    }\n\n    // Obtenir les données utilisateur du cache local\n    getCachedUser() {\n        try {\n            const userData = localStorage.getItem(this.userKey);\n            return userData ? JSON.parse(userData) : null;\n        } catch (error) {\n            console.error('Erreur lors de la récupération des données utilisateur en cache:', error);\n            return null;\n        }\n    }\n\n    // Vérifier si l'utilisateur est authentifié\n    isAuthenticated() {\n        const token = this.getToken();\n        return token && !this.isTokenExpired(token);\n    }\n\n    // Obtenir le rôle de l'utilisateur\n    getUserRole() {\n        const user = this.getCachedUser();\n        return user?.role || null;\n    }\n\n    // Vérifier si l'utilisateur a un rôle spécifique\n    hasRole(role) {\n        return this.getUserRole() === role;\n    }\n\n    // Vérifier si l'utilisateur a l'un des rôles spécifiés\n    hasAnyRole(roles) {\n        const userRole = this.getUserRole();\n        return roles.includes(userRole);\n    }\n\n    // Intercepteur pour les requêtes automatiques\n    setupInterceptors() {\n        // Intercepter toutes les requêtes fetch pour ajouter automatiquement le token\n        const originalFetch = window.fetch;\n        \n        window.fetch = async (url, options = {}) => {\n            // Vérifier si c'est une requête vers notre API\n            if (url.includes(host) || url.startsWith('/api')) {\n                const token = this.getToken();\n                \n                if (token && !this.isTokenExpired(token)) {\n                    options.headers = {\n                        ...options.headers,\n                        'Authorization': `Bearer ${token}`\n                    };\n                }\n            }\n            \n            return originalFetch(url, options);\n        };\n    }\n\n    // Restaurer les intercepteurs (si nécessaire)\n    restoreInterceptors() {\n        // Restaurer le fetch original si modifié\n        if (window.originalFetch) {\n            window.fetch = window.originalFetch;\n            delete window.originalFetch;\n        }\n    }\n}\n\n// Instance singleton du service d'authentification\nexport const authService = new AuthService();\n\n// Initialiser les intercepteurs au chargement\nif (typeof window !== 'undefined') {\n    authService.setupInterceptors();\n}\n\nexport default authService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}