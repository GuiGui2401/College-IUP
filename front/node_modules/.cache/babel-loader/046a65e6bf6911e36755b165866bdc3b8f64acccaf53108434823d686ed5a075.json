{"ast":null,"code":"import React,{createContext,useContext,useReducer,useEffect}from'react';import{authService}from'../services/authService';import{jsx as _jsx}from\"react/jsx-runtime\";const AuthContext=/*#__PURE__*/createContext(null);const initialState={user:null,token:null,isAuthenticated:false,isLoading:true,error:null,refreshTokenTimeout:null,isLoggingOut:false};const authReducer=(state,action)=>{switch(action.type){case'SET_LOADING':return{...state,isLoading:action.payload,error:null};case'LOGIN_SUCCESS':return{...state,user:action.payload.user,token:action.payload.token,isAuthenticated:true,isLoading:false,error:null};case'LOGIN_FAILURE':return{...state,user:null,token:null,isAuthenticated:false,isLoading:false,error:action.payload};case'LOGOUT_START':return{...state,isLoggingOut:true};case'LOGOUT':return{...initialState,isLoading:false};case'TOKEN_REFRESHED':return{...state,token:action.payload.token,user:action.payload.user||state.user,error:null};case'SET_ERROR':return{...state,error:action.payload,isLoading:false};case'CLEAR_ERROR':return{...state,error:null};case'SET_REFRESH_TIMEOUT':return{...state,refreshTokenTimeout:action.payload};case'CLEAR_REFRESH_TIMEOUT':if(state.refreshTokenTimeout){clearTimeout(state.refreshTokenTimeout);}return{...state,refreshTokenTimeout:null};case'UPDATE_USER':return{...state,user:action.payload};default:return state;}};export const AuthProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(authReducer,initialState);// Fonction pour configurer le refresh automatique du token\nconst setupTokenRefresh=token=>{try{// Décoder le JWT pour obtenir l'expiration\nconst payload=JSON.parse(atob(token.split('.')[1]));const expiresAt=payload.exp*1000;// Convertir en millisecondes\nconst now=Date.now();const timeUntilExpiry=expiresAt-now;// Programmer le refresh 5 minutes avant l'expiration\nconst refreshTime=Math.max(timeUntilExpiry-5*60*1000,0);if(refreshTime>0){const timeoutId=setTimeout(()=>{refreshToken();},refreshTime);dispatch({type:'SET_REFRESH_TIMEOUT',payload:timeoutId});}}catch(error){console.error('Erreur lors du décodage du token:',error);}};// Fonction de connexion\nconst login=async credentials=>{dispatch({type:'SET_LOADING',payload:true});dispatch({type:'CLEAR_ERROR'});try{const response=await authService.login(credentials);if(response.access_token&&response.user){// Stocker le token de manière sécurisée\nauthService.setToken(response.access_token);dispatch({type:'LOGIN_SUCCESS',payload:{user:response.user,token:response.access_token}});// Configurer le refresh automatique\nsetupTokenRefresh(response.access_token);return response;}else{throw new Error('Réponse invalide du serveur');}}catch(error){var _error$response,_error$response$data;const errorMessage=((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.error)||error.message||'Erreur de connexion';dispatch({type:'LOGIN_FAILURE',payload:errorMessage});throw error;}};// Fonction de déconnexion\nconst logout=async()=>{// Éviter les appels multiples de logout\nif(state.isLoggingOut){console.log('Logout déjà en cours, ignorer');return;}dispatch({type:'LOGOUT_START'});dispatch({type:'CLEAR_REFRESH_TIMEOUT'});try{await authService.logout();}catch(error){console.error('Erreur lors de la déconnexion:',error);}finally{authService.removeToken();dispatch({type:'LOGOUT'});}};// Fonction de refresh du token\nconst refreshToken=async()=>{try{const response=await authService.refreshToken();if(response.access_token){authService.setToken(response.access_token);dispatch({type:'TOKEN_REFRESHED',payload:{token:response.access_token,user:response.user}});// Configurer le prochain refresh\nsetupTokenRefresh(response.access_token);return response.access_token;}}catch(error){console.error('Erreur lors du refresh du token:',error);logout();// Forcer la déconnexion si le refresh échoue\nthrow error;}};// Fonction pour obtenir les informations utilisateur\nconst getCurrentUser=async()=>{try{const user=await authService.getCurrentUser();dispatch({type:'TOKEN_REFRESHED',payload:{user,token:state.token}});return user;}catch(error){console.error('Erreur lors de la récupération de l\\'utilisateur:',error);throw error;}};// Fonction pour vérifier si l'utilisateur a un rôle spécifique\nconst hasRole=role=>{var _state$user;return((_state$user=state.user)===null||_state$user===void 0?void 0:_state$user.role)===role;};// Fonction pour vérifier si l'utilisateur a l'un des rôles spécifiés\nconst hasAnyRole=roles=>{var _state$user2;return roles.includes((_state$user2=state.user)===null||_state$user2===void 0?void 0:_state$user2.role);};// Fonction pour nettoyer les erreurs\nconst clearError=()=>{dispatch({type:'CLEAR_ERROR'});};// Fonction pour mettre à jour l'utilisateur\nconst updateUser=userData=>{dispatch({type:'UPDATE_USER',payload:userData});};// Vérification de l'authentification au chargement\nuseEffect(()=>{const initializeAuth=async()=>{try{const token=authService.getToken();if(token){// Vérifier d'abord si le token n'est pas expiré côté client\nif(authService.isTokenExpired(token)){console.log('Token expiré détecté lors de l\\'initialisation');authService.removeToken();dispatch({type:'LOGOUT'});return;}try{// Vérifier si le token est valide côté serveur\nconst user=await authService.getCurrentUser();dispatch({type:'LOGIN_SUCCESS',payload:{user,token}});// Configurer le refresh automatique\nsetupTokenRefresh(token);}catch(error){console.error('Token invalide côté serveur:',error);// Ne pas supprimer le token ici, car l'événement auth:unauthorized le fera\n// Cela évite le double logout\ndispatch({type:'LOGOUT'});}}else{dispatch({type:'SET_LOADING',payload:false});}}catch(error){console.error('Erreur lors de l\\'initialisation de l\\'authentification:',error);// Nettoyer les données corrompues\nauthService.removeToken();dispatch({type:'LOGOUT'});}};initializeAuth();// Nettoyage au démontage\nreturn()=>{if(state.refreshTokenTimeout){clearTimeout(state.refreshTokenTimeout);}};},[]);// Intercepteur pour gérer les erreurs 401\nuseEffect(()=>{const handleUnauthorized=()=>{// Éviter les appels multiples si l'utilisateur n'est plus authentifié\nif(state.isAuthenticated){console.log('Session expirée détectée, déconnexion automatique');dispatch({type:'SET_ERROR',payload:'Session expirée'});logout();}};// Écouter les événements d'erreur d'authentification\nwindow.addEventListener('auth:unauthorized',handleUnauthorized);return()=>{window.removeEventListener('auth:unauthorized',handleUnauthorized);};},[state.isAuthenticated,logout]);const value={// État\nuser:state.user,token:state.token,isAuthenticated:state.isAuthenticated,isLoading:state.isLoading,error:state.error,// Actions\nlogin,logout,refreshToken,getCurrentUser,updateUser,hasRole,hasAnyRole,clearError};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:value,children:children});};// Hook personnalisé pour utiliser le contexte d'authentification\nexport const useAuth=()=>{const context=useContext(AuthContext);if(!context){throw new Error('useAuth doit être utilisé dans un AuthProvider');}return context;};export default AuthContext;","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","authService","jsx","_jsx","AuthContext","initialState","user","token","isAuthenticated","isLoading","error","refreshTokenTimeout","isLoggingOut","authReducer","state","action","type","payload","clearTimeout","AuthProvider","_ref","children","dispatch","setupTokenRefresh","JSON","parse","atob","split","expiresAt","exp","now","Date","timeUntilExpiry","refreshTime","Math","max","timeoutId","setTimeout","refreshToken","console","login","credentials","response","access_token","setToken","Error","_error$response","_error$response$data","errorMessage","data","message","logout","log","removeToken","getCurrentUser","hasRole","role","_state$user","hasAnyRole","roles","_state$user2","includes","clearError","updateUser","userData","initializeAuth","getToken","isTokenExpired","handleUnauthorized","window","addEventListener","removeEventListener","value","Provider","useAuth","context"],"sources":["/var/www/College-IUP/front/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport { authService } from '../services/authService';\n\nconst AuthContext = createContext(null);\n\nconst initialState = {\n    user: null,\n    token: null,\n    isAuthenticated: false,\n    isLoading: true,\n    error: null,\n    refreshTokenTimeout: null,\n    isLoggingOut: false\n};\n\nconst authReducer = (state, action) => {\n    switch (action.type) {\n        case 'SET_LOADING':\n            return {\n                ...state,\n                isLoading: action.payload,\n                error: null\n            };\n\n        case 'LOGIN_SUCCESS':\n            return {\n                ...state,\n                user: action.payload.user,\n                token: action.payload.token,\n                isAuthenticated: true,\n                isLoading: false,\n                error: null\n            };\n\n        case 'LOGIN_FAILURE':\n            return {\n                ...state,\n                user: null,\n                token: null,\n                isAuthenticated: false,\n                isLoading: false,\n                error: action.payload\n            };\n\n        case 'LOGOUT_START':\n            return {\n                ...state,\n                isLoggingOut: true\n            };\n\n        case 'LOGOUT':\n            return {\n                ...initialState,\n                isLoading: false\n            };\n\n        case 'TOKEN_REFRESHED':\n            return {\n                ...state,\n                token: action.payload.token,\n                user: action.payload.user || state.user,\n                error: null\n            };\n\n        case 'SET_ERROR':\n            return {\n                ...state,\n                error: action.payload,\n                isLoading: false\n            };\n\n        case 'CLEAR_ERROR':\n            return {\n                ...state,\n                error: null\n            };\n\n        case 'SET_REFRESH_TIMEOUT':\n            return {\n                ...state,\n                refreshTokenTimeout: action.payload\n            };\n\n        case 'CLEAR_REFRESH_TIMEOUT':\n            if (state.refreshTokenTimeout) {\n                clearTimeout(state.refreshTokenTimeout);\n            }\n            return {\n                ...state,\n                refreshTokenTimeout: null\n            };\n\n        case 'UPDATE_USER':\n            return {\n                ...state,\n                user: action.payload\n            };\n\n        default:\n            return state;\n    }\n};\n\nexport const AuthProvider = ({ children }) => {\n    const [state, dispatch] = useReducer(authReducer, initialState);\n\n    // Fonction pour configurer le refresh automatique du token\n    const setupTokenRefresh = (token) => {\n        try {\n            // Décoder le JWT pour obtenir l'expiration\n            const payload = JSON.parse(atob(token.split('.')[1]));\n            const expiresAt = payload.exp * 1000; // Convertir en millisecondes\n            const now = Date.now();\n            const timeUntilExpiry = expiresAt - now;\n            \n            // Programmer le refresh 5 minutes avant l'expiration\n            const refreshTime = Math.max(timeUntilExpiry - (5 * 60 * 1000), 0);\n            \n            if (refreshTime > 0) {\n                const timeoutId = setTimeout(() => {\n                    refreshToken();\n                }, refreshTime);\n                \n                dispatch({ type: 'SET_REFRESH_TIMEOUT', payload: timeoutId });\n            }\n        } catch (error) {\n            console.error('Erreur lors du décodage du token:', error);\n        }\n    };\n\n    // Fonction de connexion\n    const login = async (credentials) => {\n        dispatch({ type: 'SET_LOADING', payload: true });\n        dispatch({ type: 'CLEAR_ERROR' });\n\n        try {\n            const response = await authService.login(credentials);\n            \n            if (response.access_token && response.user) {\n                // Stocker le token de manière sécurisée\n                authService.setToken(response.access_token);\n                \n                dispatch({\n                    type: 'LOGIN_SUCCESS',\n                    payload: {\n                        user: response.user,\n                        token: response.access_token\n                    }\n                });\n\n                // Configurer le refresh automatique\n                setupTokenRefresh(response.access_token);\n\n                return response;\n            } else {\n                throw new Error('Réponse invalide du serveur');\n            }\n        } catch (error) {\n            const errorMessage = error.response?.data?.error || \n                                error.message || \n                                'Erreur de connexion';\n            \n            dispatch({\n                type: 'LOGIN_FAILURE',\n                payload: errorMessage\n            });\n            \n            throw error;\n        }\n    };\n\n    // Fonction de déconnexion\n    const logout = async () => {\n        // Éviter les appels multiples de logout\n        if (state.isLoggingOut) {\n            console.log('Logout déjà en cours, ignorer');\n            return;\n        }\n        \n        dispatch({ type: 'LOGOUT_START' });\n        dispatch({ type: 'CLEAR_REFRESH_TIMEOUT' });\n        \n        try {\n            await authService.logout();\n        } catch (error) {\n            console.error('Erreur lors de la déconnexion:', error);\n        } finally {\n            authService.removeToken();\n            dispatch({ type: 'LOGOUT' });\n        }\n    };\n\n    // Fonction de refresh du token\n    const refreshToken = async () => {\n        try {\n            const response = await authService.refreshToken();\n            \n            if (response.access_token) {\n                authService.setToken(response.access_token);\n                \n                dispatch({\n                    type: 'TOKEN_REFRESHED',\n                    payload: {\n                        token: response.access_token,\n                        user: response.user\n                    }\n                });\n\n                // Configurer le prochain refresh\n                setupTokenRefresh(response.access_token);\n                \n                return response.access_token;\n            }\n        } catch (error) {\n            console.error('Erreur lors du refresh du token:', error);\n            logout(); // Forcer la déconnexion si le refresh échoue\n            throw error;\n        }\n    };\n\n    // Fonction pour obtenir les informations utilisateur\n    const getCurrentUser = async () => {\n        try {\n            const user = await authService.getCurrentUser();\n            dispatch({\n                type: 'TOKEN_REFRESHED',\n                payload: { user, token: state.token }\n            });\n            return user;\n        } catch (error) {\n            console.error('Erreur lors de la récupération de l\\'utilisateur:', error);\n            throw error;\n        }\n    };\n\n    // Fonction pour vérifier si l'utilisateur a un rôle spécifique\n    const hasRole = (role) => {\n        return state.user?.role === role;\n    };\n\n    // Fonction pour vérifier si l'utilisateur a l'un des rôles spécifiés\n    const hasAnyRole = (roles) => {\n        return roles.includes(state.user?.role);\n    };\n\n    // Fonction pour nettoyer les erreurs\n    const clearError = () => {\n        dispatch({ type: 'CLEAR_ERROR' });\n    };\n\n    // Fonction pour mettre à jour l'utilisateur\n    const updateUser = (userData) => {\n        dispatch({ type: 'UPDATE_USER', payload: userData });\n    };\n\n    // Vérification de l'authentification au chargement\n    useEffect(() => {\n        const initializeAuth = async () => {\n            try {\n                const token = authService.getToken();\n                \n                if (token) {\n                    // Vérifier d'abord si le token n'est pas expiré côté client\n                    if (authService.isTokenExpired(token)) {\n                        console.log('Token expiré détecté lors de l\\'initialisation');\n                        authService.removeToken();\n                        dispatch({ type: 'LOGOUT' });\n                        return;\n                    }\n                    \n                    try {\n                        // Vérifier si le token est valide côté serveur\n                        const user = await authService.getCurrentUser();\n                        \n                        dispatch({\n                            type: 'LOGIN_SUCCESS',\n                            payload: { user, token }\n                        });\n\n                        // Configurer le refresh automatique\n                        setupTokenRefresh(token);\n                    } catch (error) {\n                        console.error('Token invalide côté serveur:', error);\n                        // Ne pas supprimer le token ici, car l'événement auth:unauthorized le fera\n                        // Cela évite le double logout\n                        dispatch({ type: 'LOGOUT' });\n                    }\n                } else {\n                    dispatch({ type: 'SET_LOADING', payload: false });\n                }\n            } catch (error) {\n                console.error('Erreur lors de l\\'initialisation de l\\'authentification:', error);\n                // Nettoyer les données corrompues\n                authService.removeToken();\n                dispatch({ type: 'LOGOUT' });\n            }\n        };\n\n        initializeAuth();\n\n        // Nettoyage au démontage\n        return () => {\n            if (state.refreshTokenTimeout) {\n                clearTimeout(state.refreshTokenTimeout);\n            }\n        };\n    }, []);\n\n    // Intercepteur pour gérer les erreurs 401\n    useEffect(() => {\n        const handleUnauthorized = () => {\n            // Éviter les appels multiples si l'utilisateur n'est plus authentifié\n            if (state.isAuthenticated) {\n                console.log('Session expirée détectée, déconnexion automatique');\n                dispatch({ type: 'SET_ERROR', payload: 'Session expirée' });\n                logout();\n            }\n        };\n\n        // Écouter les événements d'erreur d'authentification\n        window.addEventListener('auth:unauthorized', handleUnauthorized);\n\n        return () => {\n            window.removeEventListener('auth:unauthorized', handleUnauthorized);\n        };\n    }, [state.isAuthenticated, logout]);\n\n    const value = {\n        // État\n        user: state.user,\n        token: state.token,\n        isAuthenticated: state.isAuthenticated,\n        isLoading: state.isLoading,\n        error: state.error,\n\n        // Actions\n        login,\n        logout,\n        refreshToken,\n        getCurrentUser,\n        updateUser,\n        hasRole,\n        hasAnyRole,\n        clearError\n    };\n\n    return (\n        <AuthContext.Provider value={value}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\n// Hook personnalisé pour utiliser le contexte d'authentification\nexport const useAuth = () => {\n    const context = useContext(AuthContext);\n    \n    if (!context) {\n        throw new Error('useAuth doit être utilisé dans un AuthProvider');\n    }\n    \n    return context;\n};\n\nexport default AuthContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}